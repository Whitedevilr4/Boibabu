const mongoose = require('mongoose');
const Book = require('./Book');
const { createNotification } = require('../utils/notificationService');
const { sendOrderConfirmationEmail, sendOrderDeliveredEmail, sendSellerOrderNotificationEmail, sendRefundConfirmationEmail } = require('../utils/emailService');

const orderSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  orderNumber: {
    type: String,
    unique: true
    // Not required since it's auto-generated by pre-save hook
  },
  items: [{
    book: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Book',
      required: true
    },
    quantity: {
      type: Number,
      required: true,
      min: 1
    },
    price: {
      type: Number,
      required: true
    }
  }],
  shippingAddress: {
    name: String,
    street: String,
    landmark: String,
    city: String,
    state: String,
    zipCode: String,
    country: String,
    phone: String
  },
  paymentMethod: {
    type: String,
    required: true,
    enum: ['credit_card', 'debit_card', 'paypal', 'cash_on_delivery', 'razorpay']
  },
  paymentStatus: {
    type: String,
    enum: ['pending', 'paid', 'failed', 'refunded', 'partially_refunded'],
    default: 'pending'
  },
  refundAmount: {
    type: Number,
    default: 0
  },
  refundReason: {
    type: String
  },
  refundedAt: {
    type: Date
  },
  refundedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  razorpayOrderId: String,
  razorpayPaymentId: String,
  orderStatus: {
    type: String,
    enum: ['pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'returned'],
    default: 'pending'
  },
  subtotal: {
    type: Number,
    required: true
  },
  shippingCost: {
    type: Number,
    default: 0
  },
  tax: {
    type: Number,
    default: 0
  },
  total: {
    type: Number,
    required: true
  },
  couponDiscount: {
    type: Number,
    default: 0
  },
  appliedCoupon: {
    code: { type: String },
    description: { type: String },
    type: { type: String }, // Coupon type (fixed, percentage, etc.)
    value: { type: Number }
  },
  // Payment tracking for sellers
  sellerPayments: [{
    seller: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    itemsTotal: {
      type: Number,
      required: true // Total value of items from this seller
    },
    adminCommission: {
      type: Number,
      required: true // Commission amount (calculated from commissionRate)
    },
    commissionRate: {
      type: Number,
      default: 2.5 // Commission rate percentage (can be edited per order)
    },
    shippingCharges: {
      type: Number,
      default: 0 // Shipping charges (deducted from seller payment)
    },
    netAmount: {
      type: Number,
      required: true // itemsTotal - adminCommission - shippingCharges
    },
    paymentStatus: {
      type: String,
      enum: ['pending', 'due', 'paid'],
      default: 'pending'
    },
    paidAt: Date,
    paidBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    notes: String
  }],
  trackingNumber: String,
  estimatedDelivery: Date,
  deliveredAt: Date,
  notes: String,
  statusHistory: [{
    status: {
      type: String,
      enum: ['pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled', 'returned'],
      required: true
    },
    timestamp: {
      type: Date,
      default: Date.now
    },
    updatedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    notes: String
  }]
}, {
  timestamps: true
});

// Generate order number before saving
orderSchema.pre('save', async function(next) {
  if (!this.orderNumber) {
    try {
      const count = await mongoose.model('Order').countDocuments();
      this.orderNumber = `ORD${Date.now()}${String(count + 1).padStart(4, '0')}`;
    } catch (error) {
      // Fallback if count fails
      this.orderNumber = `ORD${Date.now()}${Math.floor(Math.random() * 10000)}`;
    }
  }
  next();
});

// Handle stock reduction and notifications on status change
orderSchema.pre('save', async function(next) {
  if (this.isModified('orderStatus')) {
    const oldStatus = this._original?.orderStatus;
    const newStatus = this.orderStatus;

    console.log(`Order ${this.orderNumber} status changing from ${oldStatus} to ${newStatus}`);

    // Add status change to history
    if (!this.statusHistory) {
      this.statusHistory = [];
    }
    
    // Add new status to history if it's different from the last one
    const lastStatus = this.statusHistory[this.statusHistory.length - 1];
    if (!lastStatus || lastStatus.status !== newStatus) {
      this.statusHistory.push({
        status: newStatus,
        timestamp: new Date(),
        updatedBy: this._updatedBy || null,
        notes: this._statusNotes || null
      });
      console.log(`Added status ${newStatus} to history. Total history entries: ${this.statusHistory.length}`);
    }

    // Reduce stock when order is confirmed (successful order placement)
    // This handles both new orders created as 'confirmed' and status changes to 'confirmed'
    if (newStatus === 'confirmed' && oldStatus !== 'confirmed') {
      try {
        for (const item of this.items) {
          const book = await Book.findById(item.book);
          if (book && book.stock >= item.quantity) {
            book.stock -= item.quantity;
            await book.save();
            console.log(`Reduced stock for book ${book.title}: ${item.quantity} units`);
          } else {
            console.warn(`Insufficient stock for book ${book?.title || item.book}: requested ${item.quantity}, available ${book?.stock || 0}`);
          }
        }

        // Send order confirmation email to user (for new orders and status changes to confirmed)
        try {
          await this.populate('user', 'name email');
          await this.populate('items.book', 'title author');
          
          await sendOrderConfirmationEmail(
            this.user.email,
            this.user.name,
            this
          );
          console.log(`Order confirmation email sent for order ${this.orderNumber}`);
        } catch (emailError) {
          console.error('Error sending order confirmation email:', emailError);
        }

        // Notify sellers about new order (for both new orders and status changes to confirmed)
        try {
          await this.notifySellersAboutNewOrder();
          console.log(`Seller notifications sent for order ${this.orderNumber}`);
        } catch (sellerError) {
          console.error('Error notifying sellers about new order:', sellerError);
        }

        console.log(`Stock reduced for confirmed order ${this.orderNumber}`);
      } catch (error) {
        console.error('Error reducing stock:', error);
      }
    }

    // Restore stock when order is cancelled
    if (newStatus === 'cancelled' && oldStatus !== 'cancelled') {
      try {
        for (const item of this.items) {
          const book = await Book.findById(item.book);
          if (book) {
            book.stock += item.quantity;
            await book.save();
            console.log(`Restored stock for book ${book.title}: ${item.quantity} units`);
          }
        }

        // Restore coupon usage if coupon was applied
        if (this.appliedCoupon && this.appliedCoupon.code) {
          const Coupon = require('./Coupon');
          const coupon = await Coupon.findOne({ code: this.appliedCoupon.code });
          if (coupon && coupon.usedCount > 0) {
            coupon.usedCount -= 1;
            await coupon.save();
            console.log(`Restored coupon usage for ${coupon.code}. New usage count: ${coupon.usedCount}`);
          }
        }

        // Create notification for user
        await createNotification(
          this.user,
          'order',
          'Order Cancelled âŒ',
          `Your order ${this.orderNumber} has been cancelled. The amount will be refunded within 5-7 business days.`,
          { orderId: this._id }
        );

        // Notify sellers about cancellation
        await this.notifySellersAboutCancellation();

        console.log(`Stock restored for cancelled order ${this.orderNumber}`);
      } catch (error) {
        console.error('Error restoring stock:', error);
      }
    }

    // Set delivered date when order is delivered
    if (newStatus === 'delivered' && oldStatus !== 'delivered') {
      this.deliveredAt = new Date();

      // Calculate seller payments when order is delivered
      await this.calculateSellerPayments();

      // Create delivery notification for user
      await createNotification(
        this.user,
        'delivery',
        'Order Delivered! ðŸ“¦',
        `Your order ${this.orderNumber} has been delivered successfully. Thank you for shopping with us!`,
        { orderId: this._id }
      );

      // Send order delivered email to user
      try {
        await this.populate('user', 'name email');
        await this.populate('items.book', 'title author');
        
        await sendOrderDeliveredEmail(
          this.user.email,
          this.user.name,
          this
        );
        console.log(`Order delivered email sent for order ${this.orderNumber}`);
      } catch (emailError) {
        console.error('Error sending order delivered email:', emailError);
      }

      console.log(`Delivery notification sent for order ${this.orderNumber}`);
    }

    // Handle return & refund when order status is set to returned
    if (newStatus === 'returned' && oldStatus !== 'returned') {
      // Process full refund
      const refundAmount = this.total - (this.refundAmount || 0);
      if (refundAmount > 0) {
        this.refundAmount = this.total;
        this.refundReason = 'Order returned and refunded';
        this.refundedAt = new Date();
        this.refundedBy = this._updatedBy;
        this.paymentStatus = 'refunded';
      }

      // Restore stock
      try {
        for (const item of this.items) {
          const book = await Book.findById(item.book);
          if (book) {
            book.stock += item.quantity;
            await book.save();
            console.log(`Restored stock for book ${book.title}: ${item.quantity} units`);
          }
        }
      } catch (error) {
        console.error('Error restoring stock for returned order:', error);
      }

      // Create notification for user
      await createNotification(
        this.user,
        'order',
        'Order Returned & Refunded ðŸ’°',
        `Your order ${this.orderNumber} has been returned and fully refunded. The amount will be credited to your account within 5-7 business days.`,
        { orderId: this._id }
      );

      console.log(`Return & refund processed for order ${this.orderNumber}`);
    }

    // Create notification for status updates (except initial pending status)
    if (oldStatus && oldStatus !== newStatus) {
      const statusMessages = {
        confirmed: 'Your order has been confirmed and is being processed. We\'ll notify you when it ships!',
        processing: 'Your order is being prepared for shipment. Estimated shipping time: 1-2 business days.',
        shipped: `Your order has been shipped${this.trackingNumber ? ` with tracking number: ${this.trackingNumber}` : ''}. Expected delivery: ${this.estimatedDelivery ? new Date(this.estimatedDelivery).toLocaleDateString('en-IN') : '5-7 business days'}.`,
        delivered: 'Your order has been delivered successfully. We hope you enjoy your books!',
        cancelled: 'Your order has been cancelled. If you have any questions, please contact our support team.',
        returned: 'Your order has been returned and fully refunded. The amount will be credited to your account within 5-7 business days.'
      };

      const statusIcons = {
        confirmed: 'âœ…',
        processing: 'âš™ï¸',
        shipped: 'ðŸšš',
        delivered: 'ðŸ“¦',
        cancelled: 'âŒ',
        returned: 'ðŸ’°'
      };

      if (statusMessages[newStatus]) {
        try {
          await createNotification(
            this.user,
            'order',
            `${statusIcons[newStatus]} Order ${newStatus.charAt(0).toUpperCase() + newStatus.slice(1)}`,
            statusMessages[newStatus],
            { orderId: this._id, trackingNumber: this.trackingNumber }
          );
          console.log(`Status update notification sent for order ${this.orderNumber}: ${newStatus}`);
        } catch (error) {
          console.error('Error creating status notification:', error);
        }
      }

      // Notify sellers about status changes
      try {
        await this.notifySellersAboutStatusChange(oldStatus, newStatus);
      } catch (error) {
        console.error('Error notifying sellers about status change:', error);
      }
    }
  }
  next();
});

// Store original values for comparison
orderSchema.pre('save', function(next) {
  if (!this.isNew) {
    this._original = this.toObject();
  }
  next();
});

// Method to calculate seller payments when order is delivered
orderSchema.methods.calculateSellerPayments = async function() {
  try {
    // Get global commission rate from website settings
    const WebsiteSettings = require('./WebsiteSettings');
    const settings = await WebsiteSettings.getSettings();
    const globalCommissionRate = settings.features?.commissionRate || 2.5;

    // Populate items with book and seller info
    await this.populate({
      path: 'items.book',
      populate: {
        path: 'seller',
        select: 'name email'
      }
    });

    // Group items by seller
    const sellerGroups = {};
    for (const item of this.items) {
      const sellerId = item.book.seller?._id?.toString() || 'admin';
      if (!sellerGroups[sellerId]) {
        sellerGroups[sellerId] = {
          seller: item.book.seller?._id || null,
          items: [],
          total: 0
        };
      }
      sellerGroups[sellerId].items.push(item);
      sellerGroups[sellerId].total += item.price * item.quantity;
    }

    // Calculate payments for each seller
    this.sellerPayments = [];
    const shippingPerSeller = this.shippingCost / Object.keys(sellerGroups).length; // Distribute shipping equally

    for (const [sellerId, group] of Object.entries(sellerGroups)) {
      if (group.seller) { // Only for actual sellers, not admin-created books
        const itemsTotal = group.total;
        const commissionRate = globalCommissionRate; // Use global rate from settings
        const adminCommission = Math.abs(itemsTotal * (commissionRate / 100)); // Ensure positive value
        const shippingCharges = Math.abs(shippingPerSeller); // Ensure positive value
        const netAmount = itemsTotal - adminCommission - shippingCharges;

        this.sellerPayments.push({
          seller: group.seller,
          itemsTotal,
          adminCommission,
          commissionRate,
          shippingCharges,
          netAmount,
          paymentStatus: 'due' // Set to due when order is delivered
        });

        // Notify seller about payment due
        await createNotification(
          group.seller,
          'general',
          'Payment Due! ðŸ’°',
          `Your payment of â‚¹${netAmount.toFixed(2)} for order ${this.orderNumber} is now due. You'll receive payment after admin processing.`,
          {
            orderId: this._id,
            orderNumber: this.orderNumber,
            amount: netAmount,
            itemsTotal,
            adminCommission,
            shippingCharges,
            commissionRate
          }
        );
      }
    }

    console.log(`Calculated payments for ${this.sellerPayments.length} sellers for order ${this.orderNumber}`);
  } catch (error) {
    console.error('Error calculating seller payments:', error);
  }
};

// Method to mark seller payment as paid
orderSchema.methods.markSellerPaymentPaid = async function(sellerId, paidBy, notes = '') {
  const payment = this.sellerPayments.find(p => p.seller.toString() === sellerId);
  if (payment) {
    payment.paymentStatus = 'paid';
    payment.paidAt = new Date();
    payment.paidBy = paidBy;
    payment.notes = notes;
    await this.save();
    return payment;
  }
  throw new Error('Seller payment not found');
};

// Method to check if order can be cancelled
orderSchema.methods.canBeCancelled = function() {
  return ['pending', 'confirmed', 'processing'].includes(this.orderStatus);
};

// Method to cancel order
orderSchema.methods.cancelOrder = async function(reason = 'Cancelled by user') {
  if (!this.canBeCancelled()) {
    throw new Error('Order cannot be cancelled at this stage');
  }
  
  this.orderStatus = 'cancelled';
  this._statusNotes = reason;
  await this.save();
  
  return this;
};

// Method to notify sellers about new orders
orderSchema.methods.notifySellersAboutNewOrder = async function() {
  try {
    console.log(`Starting seller notification for order ${this.orderNumber}`);
    
    // Check if items are already populated, if not populate them
    if (!this.populated('items.book') || !this.items[0]?.book?.seller) {
      await this.populate({
        path: 'items.book',
        populate: {
          path: 'seller',
          select: 'name email'
        }
      });
    }

    console.log(`Order has ${this.items.length} items`);

    // Get unique sellers from the order (only books that have sellers)
    const sellers = new Map();
    for (const item of this.items) {
      if (item.book && item.book.seller && item.book.seller._id) {
        const sellerId = item.book.seller._id.toString();
        if (!sellers.has(sellerId)) {
          sellers.set(sellerId, {
            seller: item.book.seller,
            books: [],
            totalAmount: 0
          });
        }
        sellers.get(sellerId).books.push({
          book: item.book,
          title: item.book.title,
          quantity: item.quantity,
          price: item.price
        });
        sellers.get(sellerId).totalAmount += item.price * item.quantity;
        console.log(`Added book "${item.book.title}" to seller ${item.book.seller.name}`);
      } else {
        console.log(`Skipping item "${item.book?.title || 'Unknown'}" - no seller (admin-created book)`);
      }
    }

    console.log(`Found ${sellers.size} sellers to notify`);

    if (sellers.size === 0) {
      console.log(`No sellers to notify for order ${this.orderNumber} - all books are admin-created`);
      return;
    }

    // Send notifications and emails to each seller
    for (const [sellerId, sellerData] of sellers) {
      console.log(`Processing notifications for seller: ${sellerData.seller.name}`);
      
      const booksList = sellerData.books.map(book => 
        `${book.title} (Qty: ${book.quantity})`
      ).join(', ');

      // Send in-app notification
      try {
        await createNotification(
          sellerId,
          'order',
          'New Order Received! ðŸ›’',
          `You have a new order ${this.orderNumber} from ${this.shippingAddress?.name || 'Customer'}. Books: ${booksList}. Total: â‚¹${sellerData.totalAmount.toFixed(2)}`,
          {
            orderId: this._id,
            orderNumber: this.orderNumber,
            customerName: this.shippingAddress?.name,
            books: sellerData.books,
            totalAmount: sellerData.totalAmount,
            sellerName: sellerData.seller.name
          }
        );
        console.log(`âœ… In-app notification sent to seller: ${sellerData.seller.name}`);
      } catch (notificationError) {
        console.error(`âŒ Failed to send in-app notification to seller ${sellerData.seller.name}:`, notificationError);
      }

      // Send email notification
      try {
        await sendSellerOrderNotificationEmail(
          sellerData.seller.email,
          sellerData.seller.name,
          this,
          sellerData.books
        );
        console.log(`âœ… Order notification email sent to seller: ${sellerData.seller.name}`);
      } catch (emailError) {
        console.error(`âŒ Failed to send order notification email to seller ${sellerData.seller.name}:`, emailError);
      }
    }

    console.log(`ðŸŽ‰ Successfully notified ${sellers.size} sellers about order ${this.orderNumber}`);
  } catch (error) {
    console.error('âŒ Error notifying sellers about new order:', error);
  }
};

// Method to notify sellers about order cancellation
orderSchema.methods.notifySellersAboutCancellation = async function() {
  try {
    // Populate items with book and seller info
    await this.populate({
      path: 'items.book',
      populate: {
        path: 'seller',
        select: 'name email'
      }
    });

    // Get unique sellers from the order
    const sellers = new Map();
    for (const item of this.items) {
      if (item.book.seller) {
        const sellerId = item.book.seller._id.toString();
        if (!sellers.has(sellerId)) {
          sellers.set(sellerId, {
            seller: item.book.seller,
            books: [],
            totalAmount: 0
          });
        }
        sellers.get(sellerId).books.push({
          title: item.book.title,
          quantity: item.quantity,
          price: item.price
        });
        sellers.get(sellerId).totalAmount += item.price * item.quantity;
      }
    }

    // Send cancellation notifications to each seller
    for (const [sellerId, sellerData] of sellers) {
      const booksList = sellerData.books.map(book => 
        `${book.title} (Qty: ${book.quantity})`
      ).join(', ');

      await createNotification(
        sellerId,
        'order',
        'Order Cancelled âŒ',
        `Order ${this.orderNumber} has been cancelled. Books: ${booksList}. Amount: â‚¹${sellerData.totalAmount.toFixed(2)}. Stock has been restored.`,
        {
          orderId: this._id,
          orderNumber: this.orderNumber,
          customerName: this.shippingAddress?.name,
          books: sellerData.books,
          totalAmount: sellerData.totalAmount,
          sellerName: sellerData.seller.name,
          cancelled: true
        }
      );
    }

    console.log(`Notified ${sellers.size} sellers about cancelled order ${this.orderNumber}`);
  } catch (error) {
    console.error('Error notifying sellers about cancellation:', error);
  }
};

// Method to notify sellers about status changes
orderSchema.methods.notifySellersAboutStatusChange = async function(oldStatus, newStatus) {
  try {
    // Only notify for important status changes
    const importantStatuses = ['confirmed', 'shipped', 'delivered'];
    if (!importantStatuses.includes(newStatus)) {
      return;
    }

    // Populate items with book and seller info
    await this.populate({
      path: 'items.book',
      populate: {
        path: 'seller',
        select: 'name email'
      }
    });

    // Get unique sellers from the order
    const sellers = new Map();
    for (const item of this.items) {
      if (item.book.seller) {
        const sellerId = item.book.seller._id.toString();
        if (!sellers.has(sellerId)) {
          sellers.set(sellerId, {
            seller: item.book.seller,
            books: [],
            totalAmount: 0
          });
        }
        sellers.get(sellerId).books.push({
          title: item.book.title,
          quantity: item.quantity,
          price: item.price
        });
        sellers.get(sellerId).totalAmount += item.price * item.quantity;
      }
    }

    // Send status update notifications to each seller
    for (const [sellerId, sellerData] of sellers) {
      const booksList = sellerData.books.map(book => 
        `${book.title} (Qty: ${book.quantity})`
      ).join(', ');

      const statusMessages = {
        confirmed: `Order ${this.orderNumber} has been confirmed! Your books: ${booksList}. Customer: ${this.shippingAddress?.name || 'N/A'}`,
        shipped: `Order ${this.orderNumber} has been shipped${this.trackingNumber ? ` (Tracking: ${this.trackingNumber})` : ''}! Your books: ${booksList}`,
        delivered: `Order ${this.orderNumber} has been delivered! Your books: ${booksList}. Payment processing will begin soon.`,
        returned: `Order ${this.orderNumber} has been returned and refunded. Your books: ${booksList}. Payment adjustments will be processed.`
      };

      const statusIcons = {
        confirmed: 'âœ…',
        shipped: 'ðŸšš',
        delivered: 'ðŸ“¦',
        returned: 'ðŸ’°'
      };

      if (statusMessages[newStatus]) {
        await createNotification(
          sellerId,
          'order',
          `${statusIcons[newStatus]} Order ${newStatus.charAt(0).toUpperCase() + newStatus.slice(1)}`,
          statusMessages[newStatus],
          {
            orderId: this._id,
            orderNumber: this.orderNumber,
            customerName: this.shippingAddress?.name,
            books: sellerData.books,
            totalAmount: sellerData.totalAmount,
            sellerName: sellerData.seller.name,
            status: newStatus,
            trackingNumber: this.trackingNumber
          }
        );
      }
    }

    console.log(`Notified ${sellers.size} sellers about order ${this.orderNumber} status change to ${newStatus}`);
  } catch (error) {
    console.error('Error notifying sellers about status change:', error);
  }
};

// Method to process refund
orderSchema.methods.processRefund = async function(refundAmount, reason, refundedBy) {
  if (this.paymentStatus === 'pending') {
    throw new Error('Cannot refund unpaid order');
  }

  if (refundAmount > this.total) {
    throw new Error('Refund amount cannot exceed order total');
  }

  if (this.refundAmount + refundAmount > this.total) {
    throw new Error('Total refund amount cannot exceed order total');
  }

  this.refundAmount += refundAmount;
  this.refundReason = reason;
  this.refundedAt = new Date();
  this.refundedBy = refundedBy;

  // Update payment status
  if (this.refundAmount >= this.total) {
    this.paymentStatus = 'refunded';
  } else {
    this.paymentStatus = 'partially_refunded';
  }

  await this.save();

  // Create notification for user
  await createNotification(
    this.user,
    'order',
    'Refund Processed ðŸ’°',
    `A refund of â‚¹${refundAmount.toFixed(2)} has been processed for order ${this.orderNumber}. ${reason ? `Reason: ${reason}` : ''}`,
    { 
      orderId: this._id,
      orderNumber: this.orderNumber,
      refundAmount,
      reason
    }
  );

  // Send refund confirmation email
  try {
    await this.populate('user', 'name email');
    await sendRefundConfirmationEmail(
      this.user.email,
      this.user.name,
      this,
      refundAmount,
      reason
    );
    console.log(`Refund confirmation email sent for order ${this.orderNumber}`);
  } catch (emailError) {
    console.error('Error sending refund confirmation email:', emailError);
  }

  return this;
};

module.exports = mongoose.model('Order', orderSchema);
